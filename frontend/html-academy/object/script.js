/* Техническое задание #1

Напиши программу-переводчик.

Создай функцию translate с двумя параметрами.

Первый параметр — строка со словом на русском языке,которое нужно перевести на английский.

Второй параметр — объект с данными, в котором хранится перевод слов.

Функция должна возвращать строку вида: 'понедельник по-английски: monday'.

Первый тест. Нужно перевести слово утро. Объект с данными: 

{"утро":"morning","день":"afternoon","вечер":"evening","ночь":"night"}

Ожидаемый результат: "утро по-английски: morning"

Второй тест. Нужно перевести слово разработчик. Объект с данными: 

{"тестировщик":"tester","инженер":"engineer","разработчик":"developer","менеджер":"manager"}

Ожидаемый результат: "разработчик по-английски: developer"

Третий тест. Нужно перевести слово облепиха. Объект с данными: 

{"клубника":"strawberry","голубика":"blueberry","ежевика":"blackberry","смородина":"currant","облепиха":"sea ​​buckthorn"}

Ожидаемый результат: "облепиха по-английски: sea ​​buckthorn"


*/

function f1() {
    let daysOfWeek = {
        'понедельник': 'monday',
        'вторник': 'tuesday',
        'среда': 'wednesday',
        'четверг': 'thursday',
        'пятница': 'friday',
        'суббота': 'saturday',
        'воскресенье': 'sunday'
    };

    let translate = function (wordRus, transEngArr) {
        for (let key in transEngArr) {
            if (wordRus == key)
                return `${key} по-английски: ${transEngArr[key]}`;
        };
    };
    document.querySelector('.out-1').innerHTML = ` ${translate('воскресенье', daysOfWeek)}`;

}

document.querySelector('.b-1').onclick = f1;



/* Техническое задание #2

В этой задаче вам нужно проанализировать данные — вычислить повторы каждого слова.

Создайте функцию getRepeats с одним параметром. В этот параметр будет приходить массив данных.

Функция должна возвращать объект, в котором указано сколько раз каждое слово встречается в массиве.

Первый тест. Массив данных: 

["Василий","Пётр","Иннокентий","Пётр","Иван","Василий"]

Ожидаемый результат: 

{"Василий":2,"Пётр":2,"Иннокентий":1,"Иван":1}

Второй тест. Массив данных: 

["привет","пока","прощай","пока","здравствуйте","прощай"]

Ожидаемый результат: 


Третий тест. Массив данных: 

["картошка","картошка","кофе","торт","салат","кофе","торт","картошка"]

Ожидаемый результат: 

{"картошка":3,"кофе":2,"торт":2,"салат":1}
{"привет":1,"пока":2,"прощай":2,"здравствуйте":1}

Четвёртый тест. Массив данных: 

["работа","работа","работа","работа","работа"]

Ожидаемый результат: 

{"работа":5}
*/


function f2() {
    // let getRepeats = function (arrData) {
    //     let arrObject = {};
    //     for (let i = 0; i < arrData.length; i++) {
    //         let k = 0;
    //         for (let j = 0; j < arrData.length; j++) {
    //             if (arrData[i] == arrData[j]) {
    //                 k++;
    //             };
    //         };
    //         arrObject[arrData[i]] = k;
    //     };
    //     console.log(arrObject);
    //     return arrObject;

    // };

    function getRepeats(array) {
        let repeats = {};
        for (var i = 0; i < array.length; i++) {
            let word = array[i];
            if (repeats[word]) {
                ++repeats[word];
            } else {
                repeats[word] = 1;
            }
        }
        return repeats;
    };

    getRepeats(["Василий", "Пётр", "Иннокентий", "Пётр", "Иван", "Василий"]);
    // document.querySelector('.out-2').innerHTML = 'getRepeats(["Василий", "Пётр", "Иннокентий", "Пётр", "Иван", "Василий"])] = ' + getRepeats(["Василий", "Пётр", "Иннокентий", "Пётр", "Иван", "Василий"]);
}

document.querySelector('.b-2').onclick = f2;


/* Техническое задание #3

Создайте функцию getZippedArrays.

У функции должно быть два параметра. Первый — массив с названиями ключей. Второй — массив со значениями этих ключей.

Функция должна собирать из этих двух массивов объект и возвращать его. Каждому элементу из массива ключей соответствует элемент из массива значений.

Первый тест. Массив ключей: 

["name","surname","address"]

Массив значений: 

["Асисяй","Котовий","Йошкар-Ола"]

Ожидаемый результат: 

{"name":"Асисяй","surname":"Котовий","address":"Йошкар-Ола"}

Второй тест. Массив ключей: 

["color","height","weight","depth"]

Массив значений: 

["чёрный","100","50","20"]

Ожидаемый результат: 

{"color":"чёрный","height":"100","weight":"50","depth":"20"}

Третий тест. Массив ключей: 

["country","city","month","arrivalDay","departureDay"]

Массив значений: 

["Португалия","Синтра","июль","5","10"]

Ожидаемый результат: 

{"country":"Португалия","city":"Синтра","month":"июль","arrivalDay":"5","departureDay":"10"}

*/

function f3() {
    let getZippedArrays = (arrKey, arrValueKey) => {
        let arrObject = {};
        for (let i = 0; i < arrKey.length; i++) {
            arrObject[arrKey[i]] = arrValueKey[i];
        }
        console.log(arrObject);
        // return arrObject;
    };


    getZippedArrays(["name", "surname", "address"], ["Асисяй", "Котовий", "Йошкар-Ола"]);
}

document.querySelector('.b-3').onclick = f3;


/* Техническое задание #4
Создайте функцию getSortedArray. У неё должно быть два параметра. Первый — массив, который нужно отсортировать. Второй — имя ключа в объектах. Именно по значению этого ключа нужно будет делать сортировку.

Функция должна возвращать отсортированный массив объектов.

Значения в массиве должны увеличиваться от меньшего к большему.

Первый тест. Массив 

[{"name":"Василий","age":6},{"name":"Виктор","age":4},{"name":"Пётр","age":8},{"name":"Иннокентий","age":1}]

Ключ: "age". Ожидаемый результат: 

[{"name":"Иннокентий","age":1},{"name":"Виктор","age":4},{"name":"Василий","age":6},{"name":"Пётр","age":8}]

Второй тест. Массив 

[{"name":"ирисы","price":1500},{"name":"фиалки","price":2500},{"name":"гвоздики","price":1000},{"name":"ромашки","price":1000},{"name":"тюльпаны","price":1200}]

Ключ: "price". Ожидаемый результат: 

[{"name":"гвоздики","price":1000},{"name":"ромашки","price":1000},{"name":"тюльпаны","price":1200},{"name":"ирисы","price":1500},{"name":"фиалки","price":2500}]



*/

function f4() {
    let getSortedArray = (arrSort, keySort) => {
        arrSort.sort((prev, next) => prev[keySort] - next[keySort]);
        console.log(arrSort)
        // return arrSort;
    };



    getSortedArray([{
        "name": "Василий",
        "age": 6
    }, {
        "name": "Виктор",
        "age": 4
    }, {
        "name": "Пётр",
        "age": 8
    }, {
        "name": "Иннокентий",
        "age": 1
    }], "age");
}

document.querySelector('.b-4').onclick = f4;


/* Техническое задание #5

Создайте функцию getData. У неё должно быть два параметра. Первый параметр — массив с ключами. Второй — массив с массивами данных.

Функция должна собрать объект для каждого массива значений. Каждый из этих объектов должен быть записан в массив. Именно этот массив с объектами должна вернуть функция getData.

Каждому элементу из массива ключей подходит элемент с таким же индексом в массиве значений.

Есть один нюанс: значений может оказаться больше или меньше, чем ключей.

Если значений не хватает, то создавать пустой ключ не надо. А если значений больше, то их не нужно включать в объект — для них нет ключей.


Первый тест. Массив ключей: 

["sea","country","city"]

Массив значений: 

[["Балтийское","Эстония","Силламяэ"],["Охотское","Россия","Охотск"],["Жёлтое","Китай","Бэйдайхэ"]]

Ожидаемый результат: 

[{"sea":"Балтийское","country":"Эстония","city":"Силламяэ"},{"sea":"Охотское","country":"Россия","city":"Охотск"},{"sea":"Жёлтое","country":"Китай","city":"Бэйдайхэ"}]

Второй тест. Массив ключей: 

["name","growth","weight","age"]

Массив значений: 

[["Пётр","165","70"],["Василий","170"],["Светлана"]]

Ожидаемый результат: 

[{"name":"Пётр","growth":"165","weight":"70"},{"name":"Василий","growth":"170"},{"name":"Светлана"}]

Третий тест. Массив ключей: 

["performer","album","song"]

Массив значений: 

[["Robbie Williams","The Heavy Entertainment Show","Love My Life"],["Billie Eilish","When We All Fall Asleep, Where Do We Go?","Bag Guy","17","Los Angeles"],["Монеточка","Раскраски для взрослых","90","20","Екатеринбург"]]

Ожидаемый результат: 

[{"performer":"Robbie Williams","album":"The Heavy Entertainment Show","song":"Love My Life"},{"performer":"Billie Eilish","album":"When We All Fall Asleep, Where Do We Go?","song":"Bag Guy"},{"performer":"Монеточка","album":"Раскраски для взрослых","song":"90"}]
*/



function f5() {

    let getData = (arrWithKey, arrWithArrData) => {
        let arr = [];
        for (let i = 0; i < arrWithArrData.length; i++) {
            let obj = {};
            for (let j = 0; j < arrWithKey.length; j++) {
                if (arrWithArrData[i][j]) {
                    obj[arrWithKey[j]] = arrWithArrData[i][j];
                }
            };
            arr.push(obj);
        };

        console.log(arr);
        // return arr;
    };

    getData(["name", "growth", "weight", "age"], [
        ["Пётр", "165", "70"],
        ["Василий", "170"],
        ["Светлана"],

    ]);
}

document.querySelector('.b-5').onclick = f5;